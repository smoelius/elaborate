// This file was automatically generated by `elaborate`.
// https://github.com/smoelius/elaborate

#[allow(unused_imports)]
use anyhow::Context;



#[repr(transparent)]
pub struct Child {
    pub(crate) inner: std :: process :: Child,
}
impl Child {
    pub fn to_inner(&self) -> &std :: process :: Child {
        &self.inner
    }
}
impl Child {
    pub fn into_inner(self) -> std :: process :: Child {
        self.inner
    }
}
impl<T> AsRef<T> for Child where std :: process :: Child: AsRef<T> {
    fn as_ref(&self) -> &T {
        <std :: process :: Child as AsRef<T>>::as_ref(&self.inner)
    }
}
impl From<std :: process :: Child> for Child {
    fn from(value: std :: process :: Child) -> Self {
        Self { inner: value }
    }
}
impl crate::Elaborate for std :: process :: Child {
    type Output = Child;
    fn elaborate(self) -> Self::Output {
        self.into()
    }
}
#[repr(transparent)]
pub struct Command {
    pub(crate) inner: std :: process :: Command,
}
impl Command {
    pub fn to_inner(&self) -> &std :: process :: Command {
        &self.inner
    }
}
impl Command {
    pub fn into_inner(self) -> std :: process :: Command {
        self.inner
    }
}
impl<T> AsRef<T> for Command where std :: process :: Command: AsRef<T> {
    fn as_ref(&self) -> &T {
        <std :: process :: Command as AsRef<T>>::as_ref(&self.inner)
    }
}
impl From<std :: process :: Command> for Command {
    fn from(value: std :: process :: Command) -> Self {
        Self { inner: value }
    }
}
impl crate::Elaborate for std :: process :: Command {
    type Output = Command;
    fn elaborate(self) -> Self::Output {
        self.into()
    }
}
#[repr(transparent)]
pub struct ExitStatus {
    pub(crate) inner: std :: process :: ExitStatus,
}
impl ExitStatus {
    pub fn to_inner(&self) -> &std :: process :: ExitStatus {
        &self.inner
    }
}
impl ExitStatus {
    pub fn into_inner(self) -> std :: process :: ExitStatus {
        self.inner
    }
}
impl<T> AsRef<T> for ExitStatus where std :: process :: ExitStatus: AsRef<T> {
    fn as_ref(&self) -> &T {
        <std :: process :: ExitStatus as AsRef<T>>::as_ref(&self.inner)
    }
}
impl From<std :: process :: ExitStatus> for ExitStatus {
    fn from(value: std :: process :: ExitStatus) -> Self {
        Self { inner: value }
    }
}
impl crate::Elaborate for std :: process :: ExitStatus {
    type Output = ExitStatus;
    fn elaborate(self) -> Self::Output {
        self.into()
    }
}
#[cfg(feature = "exit_status_error")]
#[repr(transparent)]
pub struct ExitStatusError {
    pub(crate) inner: std :: process :: ExitStatusError,
}
#[cfg(feature = "exit_status_error")]
impl ExitStatusError {
    pub fn to_inner(&self) -> &std :: process :: ExitStatusError {
        &self.inner
    }
}
#[cfg(feature = "exit_status_error")]
impl ExitStatusError {
    pub fn into_inner(self) -> std :: process :: ExitStatusError {
        self.inner
    }
}
#[cfg(feature = "exit_status_error")]
impl<T> AsRef<T> for ExitStatusError where std :: process :: ExitStatusError: AsRef<T> {
    fn as_ref(&self) -> &T {
        <std :: process :: ExitStatusError as AsRef<T>>::as_ref(&self.inner)
    }
}
#[cfg(feature = "exit_status_error")]
impl From<std :: process :: ExitStatusError> for ExitStatusError {
    fn from(value: std :: process :: ExitStatusError) -> Self {
        Self { inner: value }
    }
}
#[cfg(feature = "exit_status_error")]
impl crate::Elaborate for std :: process :: ExitStatusError {
    type Output = ExitStatusError;
    fn elaborate(self) -> Self::Output {
        self.into()
    }
}


impl Child {
pub fn id ( & self ) -> u32 {

    std :: process :: Child :: id(&self.inner)
}
pub fn kill ( & mut self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: process :: Child :: kill(&mut self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(crate::CustomDebugMessage("value of type std::process::Child")), "kill"))
}
pub fn try_wait ( & mut self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < core :: option :: Option < std :: process :: ExitStatus > > ) {

    std :: process :: Child :: try_wait(&mut self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(crate::CustomDebugMessage("value of type std::process::Child")), "try_wait"))
}
pub fn wait ( & mut self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: process :: ExitStatus > ) {

    std :: process :: Child :: wait(&mut self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(crate::CustomDebugMessage("value of type std::process::Child")), "wait"))
}
pub fn wait_with_output ( self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: process :: Output > ) {

    std :: process :: Child :: wait_with_output(self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(crate::CustomDebugMessage("value of type std::process::Child")), "wait_with_output"))
}
}

impl Command {
pub fn arg < S : core :: convert :: AsRef < std :: ffi :: OsStr > > ( & mut self , arg : S ) -> & mut Self {
    let arg = arg.as_ref();

    std :: process :: Command :: arg(&mut self.inner, arg); self
}
pub fn args < I , S > ( & mut self , args : I ) -> & mut Self where I : core :: iter :: IntoIterator < Item = S > , S : core :: convert :: AsRef < std :: ffi :: OsStr > {

    std :: process :: Command :: args(&mut self.inner, args); self
}
pub fn current_dir < P : core :: convert :: AsRef < std :: path :: Path > > ( & mut self , dir : P ) -> & mut Self {
    let dir = dir.as_ref();

    std :: process :: Command :: current_dir(&mut self.inner, dir); self
}
pub fn env < K , V > ( & mut self , key : K , val : V ) -> & mut Self where K : core :: convert :: AsRef < std :: ffi :: OsStr > , V : core :: convert :: AsRef < std :: ffi :: OsStr > {
    let key = key.as_ref();
    let val = val.as_ref();

    std :: process :: Command :: env(&mut self.inner, key, val); self
}
pub fn env_clear ( & mut self ) -> & mut Self {

    std :: process :: Command :: env_clear(&mut self.inner); self
}
pub fn env_remove < K : core :: convert :: AsRef < std :: ffi :: OsStr > > ( & mut self , key : K ) -> & mut Self {
    let key = key.as_ref();

    std :: process :: Command :: env_remove(&mut self.inner, key); self
}
pub fn envs < I , K , V > ( & mut self , vars : I ) -> & mut Self where I : core :: iter :: IntoIterator < Item = ( K , V ) > , K : core :: convert :: AsRef < std :: ffi :: OsStr > , V : core :: convert :: AsRef < std :: ffi :: OsStr > {

    std :: process :: Command :: envs(&mut self.inner, vars); self
}
pub fn get_args ( & self ) -> std :: process :: CommandArgs < '_ > {

    std :: process :: Command :: get_args(&self.inner)
}
pub fn get_current_dir ( & self ) -> crate :: rewrite_output_type ! ( core :: option :: Option < & std :: path :: Path > ) {

    std :: process :: Command :: get_current_dir(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "get_current_dir"))
}
pub fn get_envs ( & self ) -> std :: process :: CommandEnvs < '_ > {

    std :: process :: Command :: get_envs(&self.inner)
}
pub fn get_program ( & self ) -> & std :: ffi :: OsStr {

    std :: process :: Command :: get_program(&self.inner)
}
pub fn new < S : core :: convert :: AsRef < std :: ffi :: OsStr > > ( program : S ) -> Self {
    let program = program.as_ref();

    std :: process :: Command :: new(program).into()
}
pub fn output ( & mut self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: process :: Output > ) {

    std :: process :: Command :: output(&mut self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&mut self.inner), "output"))
}
pub fn spawn ( & mut self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: process :: Child > ) {

    std :: process :: Command :: spawn(&mut self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&mut self.inner), "spawn"))
}
pub fn status ( & mut self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: process :: ExitStatus > ) {

    std :: process :: Command :: status(&mut self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&mut self.inner), "status"))
}
pub fn stderr < T : core :: convert :: Into < std :: process :: Stdio > > ( & mut self , cfg : T ) -> & mut Self {

    std :: process :: Command :: stderr(&mut self.inner, cfg); self
}
pub fn stdin < T : core :: convert :: Into < std :: process :: Stdio > > ( & mut self , cfg : T ) -> & mut Self {

    std :: process :: Command :: stdin(&mut self.inner, cfg); self
}
pub fn stdout < T : core :: convert :: Into < std :: process :: Stdio > > ( & mut self , cfg : T ) -> & mut Self {

    std :: process :: Command :: stdout(&mut self.inner, cfg); self
}
}

impl ExitStatus {
pub fn code ( & self ) -> crate :: rewrite_output_type ! ( core :: option :: Option < i32 > ) {

    std :: process :: ExitStatus :: code(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "code"))
}
pub fn success ( & self ) -> bool {

    std :: process :: ExitStatus :: success(&self.inner)
}
#[cfg(feature = "exit_status_error")]
pub fn exit_ok ( & self ) -> crate :: rewrite_output_type ! ( core :: result :: Result < ( ) , std :: process :: ExitStatusError > ) {

    std :: process :: ExitStatus :: exit_ok(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "exit_ok"))
}
}

#[cfg(feature = "exit_status_error")]
impl ExitStatusError {
pub fn code ( & self ) -> crate :: rewrite_output_type ! ( core :: option :: Option < i32 > ) {

    std :: process :: ExitStatusError :: code(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "code"))
}
pub fn code_nonzero ( & self ) -> crate :: rewrite_output_type ! ( core :: option :: Option < core :: num :: NonZero < i32 > > ) {

    std :: process :: ExitStatusError :: code_nonzero(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "code_nonzero"))
}
pub fn into_status ( & self ) -> std :: process :: ExitStatus {

    std :: process :: ExitStatusError :: into_status(&self.inner)
}
}
