// This file was automatically generated by `elaborate`.
// https://github.com/smoelius/elaborate

#[allow(unused_imports)]
use anyhow::Context;



#[repr(transparent)]
pub struct OsStr {
    pub(crate) inner: std :: ffi :: OsStr,
}
impl OsStr {
    pub fn to_inner(&self) -> &std :: ffi :: OsStr {
        &self.inner
    }
}
impl<T> AsRef<T> for OsStr where std :: ffi :: OsStr: AsRef<T> {
    fn as_ref(&self) -> &T {
        <std :: ffi :: OsStr as AsRef<T>>::as_ref(&self.inner)
    }
}
#[repr(transparent)]
pub struct OsString {
    pub(crate) inner: std :: ffi :: OsString,
}
impl OsString {
    pub fn to_inner(&self) -> &std :: ffi :: OsString {
        &self.inner
    }
}
impl OsString {
    pub fn into_inner(self) -> std :: ffi :: OsString {
        self.inner
    }
}
impl<T> AsRef<T> for OsString where std :: ffi :: OsString: AsRef<T> {
    fn as_ref(&self) -> &T {
        <std :: ffi :: OsString as AsRef<T>>::as_ref(&self.inner)
    }
}
impl From<std :: ffi :: OsString> for OsString {
    fn from(value: std :: ffi :: OsString) -> Self {
        Self { inner: value }
    }
}
impl crate::Elaborate for std :: ffi :: OsString {
    type Output = OsString;
    fn elaborate(self) -> Self::Output {
        self.into()
    }
}


impl OsStr {
pub fn as_encoded_bytes ( & self ) -> & [ u8 ] {

    std :: ffi :: OsStr :: as_encoded_bytes(&self.inner)
}
pub fn eq_ignore_ascii_case < S : core :: convert :: AsRef < std :: ffi :: OsStr > > ( & self , other : S ) -> bool {
    let other = other.as_ref();

    std :: ffi :: OsStr :: eq_ignore_ascii_case(&self.inner, other)
}
pub fn into_os_string ( self : std :: boxed :: Box < Self > ) -> std :: ffi :: OsString {
    let boxed_os_str = unsafe {
        std::mem::transmute::<std::boxed::Box<Self>, std::boxed::Box<std::ffi::OsStr>>(self)
    };
    std::ffi::OsStr::into_os_string(boxed_os_str)
}
pub fn is_ascii ( & self ) -> bool {

    std :: ffi :: OsStr :: is_ascii(&self.inner)
}
pub fn is_empty ( & self ) -> bool {

    std :: ffi :: OsStr :: is_empty(&self.inner)
}
pub fn len ( & self ) -> usize {

    std :: ffi :: OsStr :: len(&self.inner)
}
pub fn make_ascii_lowercase ( & mut self ) {

    std :: ffi :: OsStr :: make_ascii_lowercase(&mut self.inner)
}
pub fn make_ascii_uppercase ( & mut self ) {

    std :: ffi :: OsStr :: make_ascii_uppercase(&mut self.inner)
}
pub fn new < S : core :: convert :: AsRef < std :: ffi :: OsStr > + ? core :: marker :: Sized > ( s : & S ) -> & Self {
    let os_str = std::ffi::OsStr::new(s);
    unsafe { &*(std::ptr::from_ref::<std::ffi::OsStr>(os_str) as *const Self) }
}
pub fn to_ascii_lowercase ( & self ) -> std :: ffi :: OsString {

    std :: ffi :: OsStr :: to_ascii_lowercase(&self.inner)
}
pub fn to_ascii_uppercase ( & self ) -> std :: ffi :: OsString {

    std :: ffi :: OsStr :: to_ascii_uppercase(&self.inner)
}
pub fn to_os_string ( & self ) -> std :: ffi :: OsString {

    std :: ffi :: OsStr :: to_os_string(&self.inner)
}
pub fn to_str ( & self ) -> crate :: rewrite_output_type ! ( core :: option :: Option < & str > ) {

    std :: ffi :: OsStr :: to_str(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "to_str"))
}
pub fn to_string_lossy ( & self ) -> std :: borrow :: Cow < '_ , str > {

    std :: ffi :: OsStr :: to_string_lossy(&self.inner)
}
pub unsafe fn from_encoded_bytes_unchecked ( bytes : & [ u8 ] ) -> & Self {
    let os_str = std::ffi::OsStr::from_encoded_bytes_unchecked(bytes);
    &*(std::ptr::from_ref::<std::ffi::OsStr>(os_str) as *const Self)
}
#[cfg(feature = "os_str_display")]
pub fn display ( & self ) -> std :: ffi :: Display < '_ > {

    std :: ffi :: OsStr :: display(&self.inner)
}
#[cfg(feature = "os_str_slice")]
pub fn slice_encoded_bytes < R : core :: ops :: range :: RangeBounds < usize > > ( & self , range : R ) -> & Self {

    std :: ffi :: OsStr :: slice_encoded_bytes(&self.inner, range)
}
}

impl OsString {
pub fn as_os_str ( & self ) -> & std :: ffi :: OsStr {

    std :: ffi :: OsString :: as_os_str(&self.inner)
}
pub fn capacity ( & self ) -> usize {

    std :: ffi :: OsString :: capacity(&self.inner)
}
pub fn clear ( & mut self ) {

    std :: ffi :: OsString :: clear(&mut self.inner)
}
pub fn into_boxed_os_str ( self ) -> std :: boxed :: Box < std :: ffi :: OsStr > {

    std :: ffi :: OsString :: into_boxed_os_str(self.inner)
}
pub fn into_encoded_bytes ( self ) -> std :: vec :: Vec < u8 > {

    std :: ffi :: OsString :: into_encoded_bytes(self.inner)
}
pub fn into_string ( self ) -> core :: result :: Result < std :: string :: String , Self > {

    std :: ffi :: OsString :: into_string(self.inner)
        .map_err(Into::into)
}
pub fn new ( ) -> Self {

    std :: ffi :: OsString :: new().into()
}
pub fn push < T : core :: convert :: AsRef < std :: ffi :: OsStr > > ( & mut self , s : T ) {
    let s = s.as_ref();

    std :: ffi :: OsString :: push(&mut self.inner, s)
}
pub fn reserve ( & mut self , additional : usize ) {

    std :: ffi :: OsString :: reserve(&mut self.inner, additional)
}
pub fn reserve_exact ( & mut self , additional : usize ) {

    std :: ffi :: OsString :: reserve_exact(&mut self.inner, additional)
}
pub fn shrink_to ( & mut self , min_capacity : usize ) {

    std :: ffi :: OsString :: shrink_to(&mut self.inner, min_capacity)
}
pub fn shrink_to_fit ( & mut self ) {

    std :: ffi :: OsString :: shrink_to_fit(&mut self.inner)
}
pub fn try_reserve ( & mut self , additional : usize ) -> crate :: rewrite_output_type ! ( core :: result :: Result < ( ) , std :: collections :: TryReserveError > ) {

    std :: ffi :: OsString :: try_reserve(&mut self.inner, additional)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&mut self.inner), "try_reserve", additional))
}
pub fn try_reserve_exact ( & mut self , additional : usize ) -> crate :: rewrite_output_type ! ( core :: result :: Result < ( ) , std :: collections :: TryReserveError > ) {

    std :: ffi :: OsString :: try_reserve_exact(&mut self.inner, additional)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&mut self.inner), "try_reserve_exact", additional))
}
pub fn with_capacity ( capacity : usize ) -> Self {

    std :: ffi :: OsString :: with_capacity(capacity).into()
}
pub unsafe fn from_encoded_bytes_unchecked ( bytes : std :: vec :: Vec < u8 > ) -> Self {

    std :: ffi :: OsString :: from_encoded_bytes_unchecked(bytes).into()
}
#[cfg(feature = "os_string_pathbuf_leak")]
pub fn leak < 'a > ( self ) -> & 'a mut std :: ffi :: OsStr {

    std :: ffi :: OsString :: leak(self.inner)
}
}
