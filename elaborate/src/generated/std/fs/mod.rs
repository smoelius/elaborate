// This file was automatically generated by `elaborate`.
// https://github.com/smoelius/elaborate

#[allow(unused_imports)]
use anyhow::Context;



#[repr(transparent)]
pub struct DirBuilder {
    pub(crate) inner: std :: fs :: DirBuilder,
}
impl DirBuilder {
    pub fn to_inner(&self) -> &std :: fs :: DirBuilder {
        &self.inner
    }

    
    pub fn into_inner(self) -> std :: fs :: DirBuilder {
        self.inner
    }
}
impl<T> AsRef<T> for DirBuilder where std :: fs :: DirBuilder: AsRef<T> {
    fn as_ref(&self) -> &T {
        <std :: fs :: DirBuilder as AsRef<T>>::as_ref(&self.inner)
    }
}

impl From<std :: fs :: DirBuilder> for DirBuilder {
    fn from(value: std :: fs :: DirBuilder) -> Self {
        Self { inner: value }
    }
}

impl crate::Elaborate for std :: fs :: DirBuilder {
    type Output = DirBuilder;
    fn elaborate(self) -> Self::Output {
        self.into()
    }
}
#[repr(transparent)]
pub struct DirEntry {
    pub(crate) inner: std :: fs :: DirEntry,
}
impl DirEntry {
    pub fn to_inner(&self) -> &std :: fs :: DirEntry {
        &self.inner
    }

    
    pub fn into_inner(self) -> std :: fs :: DirEntry {
        self.inner
    }
}
impl<T> AsRef<T> for DirEntry where std :: fs :: DirEntry: AsRef<T> {
    fn as_ref(&self) -> &T {
        <std :: fs :: DirEntry as AsRef<T>>::as_ref(&self.inner)
    }
}

impl From<std :: fs :: DirEntry> for DirEntry {
    fn from(value: std :: fs :: DirEntry) -> Self {
        Self { inner: value }
    }
}

impl crate::Elaborate for std :: fs :: DirEntry {
    type Output = DirEntry;
    fn elaborate(self) -> Self::Output {
        self.into()
    }
}
#[repr(transparent)]
pub struct File {
    pub(crate) inner: std :: fs :: File,
}
impl File {
    pub fn to_inner(&self) -> &std :: fs :: File {
        &self.inner
    }

    
    pub fn into_inner(self) -> std :: fs :: File {
        self.inner
    }
}
impl<T> AsRef<T> for File where std :: fs :: File: AsRef<T> {
    fn as_ref(&self) -> &T {
        <std :: fs :: File as AsRef<T>>::as_ref(&self.inner)
    }
}

impl From<std :: fs :: File> for File {
    fn from(value: std :: fs :: File) -> Self {
        Self { inner: value }
    }
}

impl crate::Elaborate for std :: fs :: File {
    type Output = File;
    fn elaborate(self) -> Self::Output {
        self.into()
    }
}
#[repr(transparent)]
pub struct Metadata {
    pub(crate) inner: std :: fs :: Metadata,
}
impl Metadata {
    pub fn to_inner(&self) -> &std :: fs :: Metadata {
        &self.inner
    }

    
    pub fn into_inner(self) -> std :: fs :: Metadata {
        self.inner
    }
}
impl<T> AsRef<T> for Metadata where std :: fs :: Metadata: AsRef<T> {
    fn as_ref(&self) -> &T {
        <std :: fs :: Metadata as AsRef<T>>::as_ref(&self.inner)
    }
}

impl From<std :: fs :: Metadata> for Metadata {
    fn from(value: std :: fs :: Metadata) -> Self {
        Self { inner: value }
    }
}

impl crate::Elaborate for std :: fs :: Metadata {
    type Output = Metadata;
    fn elaborate(self) -> Self::Output {
        self.into()
    }
}
#[repr(transparent)]
pub struct OpenOptions {
    pub(crate) inner: std :: fs :: OpenOptions,
}
impl OpenOptions {
    pub fn to_inner(&self) -> &std :: fs :: OpenOptions {
        &self.inner
    }

    
    pub fn into_inner(self) -> std :: fs :: OpenOptions {
        self.inner
    }
}
impl<T> AsRef<T> for OpenOptions where std :: fs :: OpenOptions: AsRef<T> {
    fn as_ref(&self) -> &T {
        <std :: fs :: OpenOptions as AsRef<T>>::as_ref(&self.inner)
    }
}

impl From<std :: fs :: OpenOptions> for OpenOptions {
    fn from(value: std :: fs :: OpenOptions) -> Self {
        Self { inner: value }
    }
}

impl crate::Elaborate for std :: fs :: OpenOptions {
    type Output = OpenOptions;
    fn elaborate(self) -> Self::Output {
        self.into()
    }
}


pub fn canonicalize < P : core :: convert :: AsRef < std :: path :: Path > > ( path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: path :: PathBuf > ) {
    let path = path.as_ref();

    std :: fs :: canonicalize(path)
        .map(Into::into)
        .with_context(|| crate::call_failed!(None::<()>, "std :: fs :: canonicalize", path))
}
pub fn copy < P : core :: convert :: AsRef < std :: path :: Path > , Q : core :: convert :: AsRef < std :: path :: Path > > ( from : P , to : Q ) -> crate :: rewrite_output_type ! ( std :: io :: Result < u64 > ) {
    let from = from.as_ref();
    let to = to.as_ref();

    std :: fs :: copy(from, to)
        .map(Into::into)
        .with_context(|| crate::call_failed!(None::<()>, "std :: fs :: copy", from, to))
}
pub fn create_dir < P : core :: convert :: AsRef < std :: path :: Path > > ( path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    let path = path.as_ref();

    std :: fs :: create_dir(path)
        .map(Into::into)
        .with_context(|| crate::call_failed!(None::<()>, "std :: fs :: create_dir", path))
}
pub fn create_dir_all < P : core :: convert :: AsRef < std :: path :: Path > > ( path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    let path = path.as_ref();

    std :: fs :: create_dir_all(path)
        .map(Into::into)
        .with_context(|| crate::call_failed!(None::<()>, "std :: fs :: create_dir_all", path))
}
pub fn exists < P : core :: convert :: AsRef < std :: path :: Path > > ( path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < bool > ) {
    let path = path.as_ref();

    std :: fs :: exists(path)
        .map(Into::into)
        .with_context(|| crate::call_failed!(None::<()>, "std :: fs :: exists", path))
}
pub fn hard_link < P : core :: convert :: AsRef < std :: path :: Path > , Q : core :: convert :: AsRef < std :: path :: Path > > ( original : P , link : Q ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    let original = original.as_ref();
    let link = link.as_ref();

    std :: fs :: hard_link(original, link)
        .map(Into::into)
        .with_context(|| crate::call_failed!(None::<()>, "std :: fs :: hard_link", original, link))
}
pub fn metadata < P : core :: convert :: AsRef < std :: path :: Path > > ( path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: fs :: Metadata > ) {
    let path = path.as_ref();

    std :: fs :: metadata(path)
        .map(Into::into)
        .with_context(|| crate::call_failed!(None::<()>, "std :: fs :: metadata", path))
}
pub fn read < P : core :: convert :: AsRef < std :: path :: Path > > ( path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: vec :: Vec < u8 > > ) {
    let path = path.as_ref();

    std :: fs :: read(path)
        .map(Into::into)
        .with_context(|| crate::call_failed!(None::<()>, "std :: fs :: read", path))
}
pub fn read_dir < P : core :: convert :: AsRef < std :: path :: Path > > ( path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: fs :: ReadDir > ) {
    let path = path.as_ref();

    std :: fs :: read_dir(path)
        .map(Into::into)
        .with_context(|| crate::call_failed!(None::<()>, "std :: fs :: read_dir", path))
}
pub fn read_link < P : core :: convert :: AsRef < std :: path :: Path > > ( path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: path :: PathBuf > ) {
    let path = path.as_ref();

    std :: fs :: read_link(path)
        .map(Into::into)
        .with_context(|| crate::call_failed!(None::<()>, "std :: fs :: read_link", path))
}
pub fn read_to_string < P : core :: convert :: AsRef < std :: path :: Path > > ( path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: string :: String > ) {
    let path = path.as_ref();

    std :: fs :: read_to_string(path)
        .map(Into::into)
        .with_context(|| crate::call_failed!(None::<()>, "std :: fs :: read_to_string", path))
}
pub fn remove_dir < P : core :: convert :: AsRef < std :: path :: Path > > ( path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    let path = path.as_ref();

    std :: fs :: remove_dir(path)
        .map(Into::into)
        .with_context(|| crate::call_failed!(None::<()>, "std :: fs :: remove_dir", path))
}
pub fn remove_dir_all < P : core :: convert :: AsRef < std :: path :: Path > > ( path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    let path = path.as_ref();

    std :: fs :: remove_dir_all(path)
        .map(Into::into)
        .with_context(|| crate::call_failed!(None::<()>, "std :: fs :: remove_dir_all", path))
}
pub fn remove_file < P : core :: convert :: AsRef < std :: path :: Path > > ( path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    let path = path.as_ref();

    std :: fs :: remove_file(path)
        .map(Into::into)
        .with_context(|| crate::call_failed!(None::<()>, "std :: fs :: remove_file", path))
}
pub fn rename < P : core :: convert :: AsRef < std :: path :: Path > , Q : core :: convert :: AsRef < std :: path :: Path > > ( from : P , to : Q ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    let from = from.as_ref();
    let to = to.as_ref();

    std :: fs :: rename(from, to)
        .map(Into::into)
        .with_context(|| crate::call_failed!(None::<()>, "std :: fs :: rename", from, to))
}
pub fn set_permissions < P : core :: convert :: AsRef < std :: path :: Path > > ( path : P , perm : std :: fs :: Permissions ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    let path = path.as_ref();

    std :: fs :: set_permissions(path, perm.clone())
        .map(Into::into)
        .with_context(|| crate::call_failed!(None::<()>, "std :: fs :: set_permissions", path, perm))
}
pub fn soft_link < P : core :: convert :: AsRef < std :: path :: Path > , Q : core :: convert :: AsRef < std :: path :: Path > > ( original : P , link : Q ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    let original = original.as_ref();
    let link = link.as_ref();

    std :: fs :: soft_link(original, link)
        .map(Into::into)
        .with_context(|| crate::call_failed!(None::<()>, "std :: fs :: soft_link", original, link))
}
pub fn symlink_metadata < P : core :: convert :: AsRef < std :: path :: Path > > ( path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: fs :: Metadata > ) {
    let path = path.as_ref();

    std :: fs :: symlink_metadata(path)
        .map(Into::into)
        .with_context(|| crate::call_failed!(None::<()>, "std :: fs :: symlink_metadata", path))
}
pub fn write < P : core :: convert :: AsRef < std :: path :: Path > , C : core :: convert :: AsRef < [ u8 ] > > ( path : P , contents : C ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    let path = path.as_ref();
    let contents = contents.as_ref();

    std :: fs :: write(path, contents)
        .map(Into::into)
        .with_context(|| crate::call_failed!(None::<()>, "std :: fs :: write", path, contents))
}

impl DirBuilder {
pub fn create < P : core :: convert :: AsRef < std :: path :: Path > > ( & self , path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    let path = path.as_ref();

    std :: fs :: DirBuilder :: create(&self.inner, path)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "create", path))
}
pub fn new ( ) -> Self {

    std :: fs :: DirBuilder :: new().into()
}
pub fn recursive ( & mut self , recursive : bool ) -> & mut Self {

    std :: fs :: DirBuilder :: recursive(&mut self.inner, recursive); self
}
}

impl DirEntry {
pub fn file_name ( & self ) -> std :: ffi :: OsString {

    std :: fs :: DirEntry :: file_name(&self.inner)
}
pub fn file_type ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: fs :: FileType > ) {

    std :: fs :: DirEntry :: file_type(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "file_type"))
}
pub fn metadata ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: fs :: Metadata > ) {

    std :: fs :: DirEntry :: metadata(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "metadata"))
}
pub fn path ( & self ) -> std :: path :: PathBuf {

    std :: fs :: DirEntry :: path(&self.inner)
}
}

impl File {
pub fn create < P : core :: convert :: AsRef < std :: path :: Path > > ( path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > ) {
    let path = path.as_ref();

    std :: fs :: File :: create(path)
        .map(Into::into)
        .with_context(|| crate::call_failed!(None::<()>, "std :: fs :: File :: create", path))
}
pub fn create_new < P : core :: convert :: AsRef < std :: path :: Path > > ( path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > ) {
    let path = path.as_ref();

    std :: fs :: File :: create_new(path)
        .map(Into::into)
        .with_context(|| crate::call_failed!(None::<()>, "std :: fs :: File :: create_new", path))
}
pub fn metadata ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: fs :: Metadata > ) {

    std :: fs :: File :: metadata(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "metadata"))
}
pub fn open < P : core :: convert :: AsRef < std :: path :: Path > > ( path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > ) {
    let path = path.as_ref();

    std :: fs :: File :: open(path)
        .map(Into::into)
        .with_context(|| crate::call_failed!(None::<()>, "std :: fs :: File :: open", path))
}
pub fn options ( ) -> std :: fs :: OpenOptions {

    std :: fs :: File :: options()
}
pub fn set_len ( & self , size : u64 ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: fs :: File :: set_len(&self.inner, size)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "set_len", size))
}
pub fn set_modified ( & self , time : std :: time :: SystemTime ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: fs :: File :: set_modified(&self.inner, time)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "set_modified", time))
}
pub fn set_permissions ( & self , perm : std :: fs :: Permissions ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: fs :: File :: set_permissions(&self.inner, perm.clone())
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "set_permissions", perm))
}
pub fn set_times ( & self , times : std :: fs :: FileTimes ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: fs :: File :: set_times(&self.inner, times)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "set_times", times))
}
pub fn sync_all ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: fs :: File :: sync_all(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "sync_all"))
}
pub fn sync_data ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: fs :: File :: sync_data(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "sync_data"))
}
pub fn try_clone ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > ) {

    std :: fs :: File :: try_clone(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "try_clone"))
}
}

impl Metadata {
pub fn accessed ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: time :: SystemTime > ) {

    std :: fs :: Metadata :: accessed(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "accessed"))
}
pub fn created ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: time :: SystemTime > ) {

    std :: fs :: Metadata :: created(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "created"))
}
pub fn file_type ( & self ) -> std :: fs :: FileType {

    std :: fs :: Metadata :: file_type(&self.inner)
}
pub fn is_dir ( & self ) -> bool {

    std :: fs :: Metadata :: is_dir(&self.inner)
}
pub fn is_file ( & self ) -> bool {

    std :: fs :: Metadata :: is_file(&self.inner)
}
pub fn is_symlink ( & self ) -> bool {

    std :: fs :: Metadata :: is_symlink(&self.inner)
}
pub fn len ( & self ) -> u64 {

    std :: fs :: Metadata :: len(&self.inner)
}
pub fn modified ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: time :: SystemTime > ) {

    std :: fs :: Metadata :: modified(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "modified"))
}
pub fn permissions ( & self ) -> std :: fs :: Permissions {

    std :: fs :: Metadata :: permissions(&self.inner)
}
}

impl OpenOptions {
pub fn append ( & mut self , append : bool ) -> & mut Self {

    std :: fs :: OpenOptions :: append(&mut self.inner, append); self
}
pub fn create ( & mut self , create : bool ) -> & mut Self {

    std :: fs :: OpenOptions :: create(&mut self.inner, create); self
}
pub fn create_new ( & mut self , create_new : bool ) -> & mut Self {

    std :: fs :: OpenOptions :: create_new(&mut self.inner, create_new); self
}
pub fn new ( ) -> Self {

    std :: fs :: OpenOptions :: new().into()
}
pub fn open < P : core :: convert :: AsRef < std :: path :: Path > > ( & self , path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: fs :: File > ) {
    let path = path.as_ref();

    std :: fs :: OpenOptions :: open(&self.inner, path)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "open", path))
}
pub fn read ( & mut self , read : bool ) -> & mut Self {

    std :: fs :: OpenOptions :: read(&mut self.inner, read); self
}
pub fn truncate ( & mut self , truncate : bool ) -> & mut Self {

    std :: fs :: OpenOptions :: truncate(&mut self.inner, truncate); self
}
pub fn write ( & mut self , write : bool ) -> & mut Self {

    std :: fs :: OpenOptions :: write(&mut self.inner, write); self
}
}
