// This file was automatically generated by `elaborate`.
// https://github.com/smoelius/elaborate

#[allow(unused_imports)]
use anyhow::Context;


pub trait ToSocketAddrs: std :: net :: ToSocketAddrs {
fn to_socket_addrs ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self :: Iter > ) {

    < Self as :: std :: net :: ToSocketAddrs > :: to_socket_addrs(self)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(self), "to_socket_addrs"))
}
}

impl<T> ToSocketAddrs for T where T: std :: net :: ToSocketAddrs {}

#[repr(transparent)]
pub struct TcpListener {
    pub(crate) inner: std :: net :: TcpListener,
}
impl TcpListener {
    pub fn to_inner(&self) -> &std :: net :: TcpListener {
        &self.inner
    }

    
    pub fn into_inner(self) -> std :: net :: TcpListener {
        self.inner
    }
}
impl<T> AsRef<T> for TcpListener where std :: net :: TcpListener: AsRef<T> {
    fn as_ref(&self) -> &T {
        <std :: net :: TcpListener as AsRef<T>>::as_ref(&self.inner)
    }
}

impl From<std :: net :: TcpListener> for TcpListener {
    fn from(value: std :: net :: TcpListener) -> Self {
        Self { inner: value }
    }
}

impl crate::Elaborate for std :: net :: TcpListener {
    type Output = TcpListener;
    fn elaborate(self) -> Self::Output {
        self.into()
    }
}
#[repr(transparent)]
pub struct TcpStream {
    pub(crate) inner: std :: net :: TcpStream,
}
impl TcpStream {
    pub fn to_inner(&self) -> &std :: net :: TcpStream {
        &self.inner
    }

    
    pub fn into_inner(self) -> std :: net :: TcpStream {
        self.inner
    }
}
impl<T> AsRef<T> for TcpStream where std :: net :: TcpStream: AsRef<T> {
    fn as_ref(&self) -> &T {
        <std :: net :: TcpStream as AsRef<T>>::as_ref(&self.inner)
    }
}

impl From<std :: net :: TcpStream> for TcpStream {
    fn from(value: std :: net :: TcpStream) -> Self {
        Self { inner: value }
    }
}

impl crate::Elaborate for std :: net :: TcpStream {
    type Output = TcpStream;
    fn elaborate(self) -> Self::Output {
        self.into()
    }
}
#[repr(transparent)]
pub struct UdpSocket {
    pub(crate) inner: std :: net :: UdpSocket,
}
impl UdpSocket {
    pub fn to_inner(&self) -> &std :: net :: UdpSocket {
        &self.inner
    }

    
    pub fn into_inner(self) -> std :: net :: UdpSocket {
        self.inner
    }
}
impl<T> AsRef<T> for UdpSocket where std :: net :: UdpSocket: AsRef<T> {
    fn as_ref(&self) -> &T {
        <std :: net :: UdpSocket as AsRef<T>>::as_ref(&self.inner)
    }
}

impl From<std :: net :: UdpSocket> for UdpSocket {
    fn from(value: std :: net :: UdpSocket) -> Self {
        Self { inner: value }
    }
}

impl crate::Elaborate for std :: net :: UdpSocket {
    type Output = UdpSocket;
    fn elaborate(self) -> Self::Output {
        self.into()
    }
}


impl TcpListener {
pub fn accept ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( std :: net :: TcpStream , core :: net :: SocketAddr ) > ) {

    std :: net :: TcpListener :: accept(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "accept"))
}
pub fn bind < A : std :: net :: ToSocketAddrs > ( addr : A ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > ) {

    std :: net :: TcpListener :: bind(addr)
        .map(Into::into)
        .with_context(|| crate::call_failed!(None::<()>, "std :: net :: TcpListener :: bind", crate::CustomDebugMessage("value of type impl ToSocketAddrs")))
}
pub fn incoming ( & self ) -> std :: net :: Incoming < '_ > {

    std :: net :: TcpListener :: incoming(&self.inner)
}
pub fn local_addr ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < core :: net :: SocketAddr > ) {

    std :: net :: TcpListener :: local_addr(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "local_addr"))
}
pub fn only_v6 ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < bool > ) {

    std :: net :: TcpListener :: only_v6(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "only_v6"))
}
pub fn set_nonblocking ( & self , nonblocking : bool ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: net :: TcpListener :: set_nonblocking(&self.inner, nonblocking)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "set_nonblocking", nonblocking))
}
pub fn set_only_v6 ( & self , only_v6 : bool ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: net :: TcpListener :: set_only_v6(&self.inner, only_v6)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "set_only_v6", only_v6))
}
pub fn set_ttl ( & self , ttl : u32 ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: net :: TcpListener :: set_ttl(&self.inner, ttl)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "set_ttl", ttl))
}
pub fn take_error ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < core :: option :: Option < std :: io :: Error > > ) {

    std :: net :: TcpListener :: take_error(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "take_error"))
}
pub fn try_clone ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > ) {

    std :: net :: TcpListener :: try_clone(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "try_clone"))
}
pub fn ttl ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < u32 > ) {

    std :: net :: TcpListener :: ttl(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "ttl"))
}
#[cfg(feature = "tcplistener_into_incoming")]
pub fn into_incoming ( self ) -> std :: net :: IntoIncoming {

    std :: net :: TcpListener :: into_incoming(self.inner)
}
}

impl TcpStream {
pub fn connect < A : std :: net :: ToSocketAddrs > ( addr : A ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > ) {

    std :: net :: TcpStream :: connect(addr)
        .map(Into::into)
        .with_context(|| crate::call_failed!(None::<()>, "std :: net :: TcpStream :: connect", crate::CustomDebugMessage("value of type impl ToSocketAddrs")))
}
pub fn connect_timeout ( addr : & core :: net :: SocketAddr , timeout : core :: time :: Duration ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > ) {

    std :: net :: TcpStream :: connect_timeout(addr, timeout)
        .map(Into::into)
        .with_context(|| crate::call_failed!(None::<()>, "std :: net :: TcpStream :: connect_timeout", addr, timeout))
}
pub fn local_addr ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < core :: net :: SocketAddr > ) {

    std :: net :: TcpStream :: local_addr(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "local_addr"))
}
pub fn nodelay ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < bool > ) {

    std :: net :: TcpStream :: nodelay(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "nodelay"))
}
pub fn peek ( & self , buf : & mut [ u8 ] ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {

    std :: net :: TcpStream :: peek(&self.inner, buf)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "peek", buf))
}
pub fn peer_addr ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < core :: net :: SocketAddr > ) {

    std :: net :: TcpStream :: peer_addr(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "peer_addr"))
}
pub fn read_timeout ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < core :: option :: Option < core :: time :: Duration > > ) {

    std :: net :: TcpStream :: read_timeout(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "read_timeout"))
}
pub fn set_nodelay ( & self , nodelay : bool ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: net :: TcpStream :: set_nodelay(&self.inner, nodelay)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "set_nodelay", nodelay))
}
pub fn set_nonblocking ( & self , nonblocking : bool ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: net :: TcpStream :: set_nonblocking(&self.inner, nonblocking)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "set_nonblocking", nonblocking))
}
pub fn set_read_timeout ( & self , dur : core :: option :: Option < core :: time :: Duration > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: net :: TcpStream :: set_read_timeout(&self.inner, dur)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "set_read_timeout", dur))
}
pub fn set_ttl ( & self , ttl : u32 ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: net :: TcpStream :: set_ttl(&self.inner, ttl)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "set_ttl", ttl))
}
pub fn set_write_timeout ( & self , dur : core :: option :: Option < core :: time :: Duration > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: net :: TcpStream :: set_write_timeout(&self.inner, dur)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "set_write_timeout", dur))
}
pub fn shutdown ( & self , how : std :: net :: Shutdown ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: net :: TcpStream :: shutdown(&self.inner, how)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "shutdown", how))
}
pub fn take_error ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < core :: option :: Option < std :: io :: Error > > ) {

    std :: net :: TcpStream :: take_error(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "take_error"))
}
pub fn try_clone ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > ) {

    std :: net :: TcpStream :: try_clone(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "try_clone"))
}
pub fn ttl ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < u32 > ) {

    std :: net :: TcpStream :: ttl(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "ttl"))
}
pub fn write_timeout ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < core :: option :: Option < core :: time :: Duration > > ) {

    std :: net :: TcpStream :: write_timeout(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "write_timeout"))
}
#[cfg(feature = "tcp_linger")]
pub fn linger ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < core :: option :: Option < core :: time :: Duration > > ) {

    std :: net :: TcpStream :: linger(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "linger"))
}
#[cfg(feature = "tcp_linger")]
pub fn set_linger ( & self , linger : core :: option :: Option < core :: time :: Duration > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: net :: TcpStream :: set_linger(&self.inner, linger)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "set_linger", linger))
}
}

impl UdpSocket {
pub fn bind < A : std :: net :: ToSocketAddrs > ( addr : A ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > ) {

    std :: net :: UdpSocket :: bind(addr)
        .map(Into::into)
        .with_context(|| crate::call_failed!(None::<()>, "std :: net :: UdpSocket :: bind", crate::CustomDebugMessage("value of type impl ToSocketAddrs")))
}
pub fn broadcast ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < bool > ) {

    std :: net :: UdpSocket :: broadcast(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "broadcast"))
}
pub fn connect < A : std :: net :: ToSocketAddrs > ( & self , addr : A ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: net :: UdpSocket :: connect(&self.inner, addr)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "connect", crate::CustomDebugMessage("value of type impl ToSocketAddrs")))
}
pub fn join_multicast_v4 ( & self , multiaddr : & core :: net :: Ipv4Addr , interface : & core :: net :: Ipv4Addr ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: net :: UdpSocket :: join_multicast_v4(&self.inner, multiaddr, interface)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "join_multicast_v4", multiaddr, interface))
}
pub fn join_multicast_v6 ( & self , multiaddr : & core :: net :: Ipv6Addr , interface : u32 ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: net :: UdpSocket :: join_multicast_v6(&self.inner, multiaddr, interface)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "join_multicast_v6", multiaddr, interface))
}
pub fn leave_multicast_v4 ( & self , multiaddr : & core :: net :: Ipv4Addr , interface : & core :: net :: Ipv4Addr ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: net :: UdpSocket :: leave_multicast_v4(&self.inner, multiaddr, interface)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "leave_multicast_v4", multiaddr, interface))
}
pub fn leave_multicast_v6 ( & self , multiaddr : & core :: net :: Ipv6Addr , interface : u32 ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: net :: UdpSocket :: leave_multicast_v6(&self.inner, multiaddr, interface)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "leave_multicast_v6", multiaddr, interface))
}
pub fn local_addr ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < core :: net :: SocketAddr > ) {

    std :: net :: UdpSocket :: local_addr(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "local_addr"))
}
pub fn multicast_loop_v4 ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < bool > ) {

    std :: net :: UdpSocket :: multicast_loop_v4(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "multicast_loop_v4"))
}
pub fn multicast_loop_v6 ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < bool > ) {

    std :: net :: UdpSocket :: multicast_loop_v6(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "multicast_loop_v6"))
}
pub fn multicast_ttl_v4 ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < u32 > ) {

    std :: net :: UdpSocket :: multicast_ttl_v4(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "multicast_ttl_v4"))
}
pub fn peek ( & self , buf : & mut [ u8 ] ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {

    std :: net :: UdpSocket :: peek(&self.inner, buf)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "peek", buf))
}
pub fn peek_from ( & self , buf : & mut [ u8 ] ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( usize , core :: net :: SocketAddr ) > ) {

    std :: net :: UdpSocket :: peek_from(&self.inner, buf)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "peek_from", buf))
}
pub fn peer_addr ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < core :: net :: SocketAddr > ) {

    std :: net :: UdpSocket :: peer_addr(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "peer_addr"))
}
pub fn read_timeout ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < core :: option :: Option < core :: time :: Duration > > ) {

    std :: net :: UdpSocket :: read_timeout(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "read_timeout"))
}
pub fn recv ( & self , buf : & mut [ u8 ] ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {

    std :: net :: UdpSocket :: recv(&self.inner, buf)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "recv", buf))
}
pub fn recv_from ( & self , buf : & mut [ u8 ] ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( usize , core :: net :: SocketAddr ) > ) {

    std :: net :: UdpSocket :: recv_from(&self.inner, buf)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "recv_from", buf))
}
pub fn send ( & self , buf : & [ u8 ] ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {

    std :: net :: UdpSocket :: send(&self.inner, buf)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "send", buf))
}
pub fn send_to < A : std :: net :: ToSocketAddrs > ( & self , buf : & [ u8 ] , addr : A ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {

    std :: net :: UdpSocket :: send_to(&self.inner, buf, addr)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "send_to", buf, crate::CustomDebugMessage("value of type impl ToSocketAddrs")))
}
pub fn set_broadcast ( & self , broadcast : bool ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: net :: UdpSocket :: set_broadcast(&self.inner, broadcast)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "set_broadcast", broadcast))
}
pub fn set_multicast_loop_v4 ( & self , multicast_loop_v4 : bool ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: net :: UdpSocket :: set_multicast_loop_v4(&self.inner, multicast_loop_v4)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "set_multicast_loop_v4", multicast_loop_v4))
}
pub fn set_multicast_loop_v6 ( & self , multicast_loop_v6 : bool ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: net :: UdpSocket :: set_multicast_loop_v6(&self.inner, multicast_loop_v6)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "set_multicast_loop_v6", multicast_loop_v6))
}
pub fn set_multicast_ttl_v4 ( & self , multicast_ttl_v4 : u32 ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: net :: UdpSocket :: set_multicast_ttl_v4(&self.inner, multicast_ttl_v4)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "set_multicast_ttl_v4", multicast_ttl_v4))
}
pub fn set_nonblocking ( & self , nonblocking : bool ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: net :: UdpSocket :: set_nonblocking(&self.inner, nonblocking)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "set_nonblocking", nonblocking))
}
pub fn set_read_timeout ( & self , dur : core :: option :: Option < core :: time :: Duration > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: net :: UdpSocket :: set_read_timeout(&self.inner, dur)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "set_read_timeout", dur))
}
pub fn set_ttl ( & self , ttl : u32 ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: net :: UdpSocket :: set_ttl(&self.inner, ttl)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "set_ttl", ttl))
}
pub fn set_write_timeout ( & self , dur : core :: option :: Option < core :: time :: Duration > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: net :: UdpSocket :: set_write_timeout(&self.inner, dur)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "set_write_timeout", dur))
}
pub fn take_error ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < core :: option :: Option < std :: io :: Error > > ) {

    std :: net :: UdpSocket :: take_error(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "take_error"))
}
pub fn try_clone ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > ) {

    std :: net :: UdpSocket :: try_clone(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "try_clone"))
}
pub fn ttl ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < u32 > ) {

    std :: net :: UdpSocket :: ttl(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "ttl"))
}
pub fn write_timeout ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < core :: option :: Option < core :: time :: Duration > > ) {

    std :: net :: UdpSocket :: write_timeout(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "write_timeout"))
}
}
