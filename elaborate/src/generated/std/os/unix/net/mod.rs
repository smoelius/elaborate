// This file was automatically generated by `elaborate`.
// https://github.com/smoelius/elaborate

#[allow(unused_imports)]
use anyhow::Context;



#[cfg(unix)]
#[repr(transparent)]
pub struct SocketAddr {
    pub(crate) inner: std :: os :: unix :: net :: SocketAddr,
}
#[cfg(unix)]
impl SocketAddr {
    pub fn to_inner(&self) -> &std :: os :: unix :: net :: SocketAddr {
        &self.inner
    }
}
#[cfg(unix)]
impl SocketAddr {
    pub fn into_inner(self) -> std :: os :: unix :: net :: SocketAddr {
        self.inner
    }
}
#[cfg(unix)]
impl<T> AsRef<T> for SocketAddr where std :: os :: unix :: net :: SocketAddr: AsRef<T> {
    fn as_ref(&self) -> &T {
        <std :: os :: unix :: net :: SocketAddr as AsRef<T>>::as_ref(&self.inner)
    }
}
#[cfg(unix)]
impl From<std :: os :: unix :: net :: SocketAddr> for SocketAddr {
    fn from(value: std :: os :: unix :: net :: SocketAddr) -> Self {
        Self { inner: value }
    }
}
#[cfg(unix)]
impl crate::Elaborate for std :: os :: unix :: net :: SocketAddr {
    type Output = SocketAddr;
    fn elaborate(self) -> Self::Output {
        self.into()
    }
}
#[cfg(unix)]
#[repr(transparent)]
pub struct UnixDatagram {
    pub(crate) inner: std :: os :: unix :: net :: UnixDatagram,
}
#[cfg(unix)]
impl UnixDatagram {
    pub fn to_inner(&self) -> &std :: os :: unix :: net :: UnixDatagram {
        &self.inner
    }
}
#[cfg(unix)]
impl UnixDatagram {
    pub fn into_inner(self) -> std :: os :: unix :: net :: UnixDatagram {
        self.inner
    }
}
#[cfg(unix)]
impl<T> AsRef<T> for UnixDatagram where std :: os :: unix :: net :: UnixDatagram: AsRef<T> {
    fn as_ref(&self) -> &T {
        <std :: os :: unix :: net :: UnixDatagram as AsRef<T>>::as_ref(&self.inner)
    }
}
#[cfg(unix)]
impl From<std :: os :: unix :: net :: UnixDatagram> for UnixDatagram {
    fn from(value: std :: os :: unix :: net :: UnixDatagram) -> Self {
        Self { inner: value }
    }
}
#[cfg(unix)]
impl crate::Elaborate for std :: os :: unix :: net :: UnixDatagram {
    type Output = UnixDatagram;
    fn elaborate(self) -> Self::Output {
        self.into()
    }
}
#[cfg(unix)]
#[repr(transparent)]
pub struct UnixListener {
    pub(crate) inner: std :: os :: unix :: net :: UnixListener,
}
#[cfg(unix)]
impl UnixListener {
    pub fn to_inner(&self) -> &std :: os :: unix :: net :: UnixListener {
        &self.inner
    }
}
#[cfg(unix)]
impl UnixListener {
    pub fn into_inner(self) -> std :: os :: unix :: net :: UnixListener {
        self.inner
    }
}
#[cfg(unix)]
impl<T> AsRef<T> for UnixListener where std :: os :: unix :: net :: UnixListener: AsRef<T> {
    fn as_ref(&self) -> &T {
        <std :: os :: unix :: net :: UnixListener as AsRef<T>>::as_ref(&self.inner)
    }
}
#[cfg(unix)]
impl From<std :: os :: unix :: net :: UnixListener> for UnixListener {
    fn from(value: std :: os :: unix :: net :: UnixListener) -> Self {
        Self { inner: value }
    }
}
#[cfg(unix)]
impl crate::Elaborate for std :: os :: unix :: net :: UnixListener {
    type Output = UnixListener;
    fn elaborate(self) -> Self::Output {
        self.into()
    }
}
#[cfg(unix)]
#[repr(transparent)]
pub struct UnixStream {
    pub(crate) inner: std :: os :: unix :: net :: UnixStream,
}
#[cfg(unix)]
impl UnixStream {
    pub fn to_inner(&self) -> &std :: os :: unix :: net :: UnixStream {
        &self.inner
    }
}
#[cfg(unix)]
impl UnixStream {
    pub fn into_inner(self) -> std :: os :: unix :: net :: UnixStream {
        self.inner
    }
}
#[cfg(unix)]
impl<T> AsRef<T> for UnixStream where std :: os :: unix :: net :: UnixStream: AsRef<T> {
    fn as_ref(&self) -> &T {
        <std :: os :: unix :: net :: UnixStream as AsRef<T>>::as_ref(&self.inner)
    }
}
#[cfg(unix)]
impl From<std :: os :: unix :: net :: UnixStream> for UnixStream {
    fn from(value: std :: os :: unix :: net :: UnixStream) -> Self {
        Self { inner: value }
    }
}
#[cfg(unix)]
impl crate::Elaborate for std :: os :: unix :: net :: UnixStream {
    type Output = UnixStream;
    fn elaborate(self) -> Self::Output {
        self.into()
    }
}


#[cfg(unix)]
impl SocketAddr {
pub fn as_pathname ( & self ) -> crate :: rewrite_output_type ! ( core :: option :: Option < & std :: path :: Path > ) {

    std :: os :: unix :: net :: SocketAddr :: as_pathname(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "as_pathname"))
}
pub fn from_pathname < P > ( path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > ) where P : core :: convert :: AsRef < std :: path :: Path > {
    let path = path.as_ref();

    std :: os :: unix :: net :: SocketAddr :: from_pathname(path)
        .map(Into::into)
        .with_context(|| crate::call_failed!(None::<()>, "std :: os :: unix :: net :: SocketAddr :: from_pathname", path))
}
pub fn is_unnamed ( & self ) -> bool {

    std :: os :: unix :: net :: SocketAddr :: is_unnamed(&self.inner)
}
}

#[cfg(unix)]
impl UnixDatagram {
#[cfg(feature = "unix_set_mark")]
pub fn set_mark ( & self , mark : u32 ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: os :: unix :: net :: UnixDatagram :: set_mark(&self.inner, mark)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "set_mark", mark))
}
#[cfg(feature = "unix_socket_ancillary_data")]
pub fn recv_vectored_with_ancillary ( & self , bufs : & mut [ std :: io :: IoSliceMut < '_ > ] , ancillary : & mut std :: os :: unix :: net :: SocketAncillary < '_ > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( usize , bool ) > ) {

    std :: os :: unix :: net :: UnixDatagram :: recv_vectored_with_ancillary(&self.inner, bufs, ancillary)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "recv_vectored_with_ancillary", bufs, ancillary))
}
#[cfg(feature = "unix_socket_ancillary_data")]
pub fn recv_vectored_with_ancillary_from ( & self , bufs : & mut [ std :: io :: IoSliceMut < '_ > ] , ancillary : & mut std :: os :: unix :: net :: SocketAncillary < '_ > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( usize , bool , std :: os :: unix :: net :: SocketAddr ) > ) {

    std :: os :: unix :: net :: UnixDatagram :: recv_vectored_with_ancillary_from(&self.inner, bufs, ancillary)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "recv_vectored_with_ancillary_from", bufs, ancillary))
}
#[cfg(feature = "unix_socket_ancillary_data")]
pub fn send_vectored_with_ancillary ( & self , bufs : & [ std :: io :: IoSlice < '_ > ] , ancillary : & mut std :: os :: unix :: net :: SocketAncillary < '_ > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {

    std :: os :: unix :: net :: UnixDatagram :: send_vectored_with_ancillary(&self.inner, bufs, ancillary)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "send_vectored_with_ancillary", bufs, ancillary))
}
#[cfg(feature = "unix_socket_ancillary_data")]
pub fn send_vectored_with_ancillary_to < P : core :: convert :: AsRef < std :: path :: Path > > ( & self , bufs : & [ std :: io :: IoSlice < '_ > ] , ancillary : & mut std :: os :: unix :: net :: SocketAncillary < '_ > , path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {
    let path = path.as_ref();

    std :: os :: unix :: net :: UnixDatagram :: send_vectored_with_ancillary_to(&self.inner, bufs, ancillary, path)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "send_vectored_with_ancillary_to", bufs, ancillary, path))
}
#[cfg(feature = "unix_socket_peek")]
pub fn peek ( & self , buf : & mut [ u8 ] ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {

    std :: os :: unix :: net :: UnixDatagram :: peek(&self.inner, buf)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "peek", buf))
}
#[cfg(feature = "unix_socket_peek")]
pub fn peek_from ( & self , buf : & mut [ u8 ] ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( usize , std :: os :: unix :: net :: SocketAddr ) > ) {

    std :: os :: unix :: net :: UnixDatagram :: peek_from(&self.inner, buf)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "peek_from", buf))
}
pub fn bind < P : core :: convert :: AsRef < std :: path :: Path > > ( path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > ) {
    let path = path.as_ref();

    std :: os :: unix :: net :: UnixDatagram :: bind(path)
        .map(Into::into)
        .with_context(|| crate::call_failed!(None::<()>, "std :: os :: unix :: net :: UnixDatagram :: bind", path))
}
pub fn bind_addr ( socket_addr : & std :: os :: unix :: net :: SocketAddr ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > ) {

    std :: os :: unix :: net :: UnixDatagram :: bind_addr(socket_addr)
        .map(Into::into)
        .with_context(|| crate::call_failed!(None::<()>, "std :: os :: unix :: net :: UnixDatagram :: bind_addr", socket_addr))
}
pub fn connect < P : core :: convert :: AsRef < std :: path :: Path > > ( & self , path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {
    let path = path.as_ref();

    std :: os :: unix :: net :: UnixDatagram :: connect(&self.inner, path)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "connect", path))
}
pub fn connect_addr ( & self , socket_addr : & std :: os :: unix :: net :: SocketAddr ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: os :: unix :: net :: UnixDatagram :: connect_addr(&self.inner, socket_addr)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "connect_addr", socket_addr))
}
pub fn local_addr ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: os :: unix :: net :: SocketAddr > ) {

    std :: os :: unix :: net :: UnixDatagram :: local_addr(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "local_addr"))
}
pub fn pair ( ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( Self , Self ) > ) {

    std :: os :: unix :: net :: UnixDatagram :: pair()
        .map(|(x, y)| (x.into(), y.into()))
        .with_context(|| crate::call_failed!(None::<()>, "std :: os :: unix :: net :: UnixDatagram :: pair"))
}
pub fn peer_addr ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: os :: unix :: net :: SocketAddr > ) {

    std :: os :: unix :: net :: UnixDatagram :: peer_addr(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "peer_addr"))
}
pub fn read_timeout ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < core :: option :: Option < core :: time :: Duration > > ) {

    std :: os :: unix :: net :: UnixDatagram :: read_timeout(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "read_timeout"))
}
pub fn recv ( & self , buf : & mut [ u8 ] ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {

    std :: os :: unix :: net :: UnixDatagram :: recv(&self.inner, buf)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "recv", buf))
}
pub fn recv_from ( & self , buf : & mut [ u8 ] ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( usize , std :: os :: unix :: net :: SocketAddr ) > ) {

    std :: os :: unix :: net :: UnixDatagram :: recv_from(&self.inner, buf)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "recv_from", buf))
}
pub fn send ( & self , buf : & [ u8 ] ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {

    std :: os :: unix :: net :: UnixDatagram :: send(&self.inner, buf)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "send", buf))
}
pub fn send_to < P : core :: convert :: AsRef < std :: path :: Path > > ( & self , buf : & [ u8 ] , path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {
    let path = path.as_ref();

    std :: os :: unix :: net :: UnixDatagram :: send_to(&self.inner, buf, path)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "send_to", buf, path))
}
pub fn send_to_addr ( & self , buf : & [ u8 ] , socket_addr : & std :: os :: unix :: net :: SocketAddr ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {

    std :: os :: unix :: net :: UnixDatagram :: send_to_addr(&self.inner, buf, socket_addr)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "send_to_addr", buf, socket_addr))
}
pub fn set_nonblocking ( & self , nonblocking : bool ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: os :: unix :: net :: UnixDatagram :: set_nonblocking(&self.inner, nonblocking)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "set_nonblocking", nonblocking))
}
pub fn set_read_timeout ( & self , timeout : core :: option :: Option < core :: time :: Duration > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: os :: unix :: net :: UnixDatagram :: set_read_timeout(&self.inner, timeout)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "set_read_timeout", timeout))
}
pub fn set_write_timeout ( & self , timeout : core :: option :: Option < core :: time :: Duration > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: os :: unix :: net :: UnixDatagram :: set_write_timeout(&self.inner, timeout)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "set_write_timeout", timeout))
}
pub fn shutdown ( & self , how : std :: net :: Shutdown ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: os :: unix :: net :: UnixDatagram :: shutdown(&self.inner, how)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "shutdown", how))
}
pub fn take_error ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < core :: option :: Option < std :: io :: Error > > ) {

    std :: os :: unix :: net :: UnixDatagram :: take_error(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "take_error"))
}
pub fn try_clone ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > ) {

    std :: os :: unix :: net :: UnixDatagram :: try_clone(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "try_clone"))
}
pub fn unbound ( ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > ) {

    std :: os :: unix :: net :: UnixDatagram :: unbound()
        .map(Into::into)
        .with_context(|| crate::call_failed!(None::<()>, "std :: os :: unix :: net :: UnixDatagram :: unbound"))
}
pub fn write_timeout ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < core :: option :: Option < core :: time :: Duration > > ) {

    std :: os :: unix :: net :: UnixDatagram :: write_timeout(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "write_timeout"))
}
}

#[cfg(unix)]
impl UnixListener {
pub fn accept ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( std :: os :: unix :: net :: UnixStream , std :: os :: unix :: net :: SocketAddr ) > ) {

    std :: os :: unix :: net :: UnixListener :: accept(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "accept"))
}
pub fn bind < P : core :: convert :: AsRef < std :: path :: Path > > ( path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > ) {
    let path = path.as_ref();

    std :: os :: unix :: net :: UnixListener :: bind(path)
        .map(Into::into)
        .with_context(|| crate::call_failed!(None::<()>, "std :: os :: unix :: net :: UnixListener :: bind", path))
}
pub fn bind_addr ( socket_addr : & std :: os :: unix :: net :: SocketAddr ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > ) {

    std :: os :: unix :: net :: UnixListener :: bind_addr(socket_addr)
        .map(Into::into)
        .with_context(|| crate::call_failed!(None::<()>, "std :: os :: unix :: net :: UnixListener :: bind_addr", socket_addr))
}
pub fn incoming ( & self ) -> std :: os :: unix :: net :: Incoming < '_ > {

    std :: os :: unix :: net :: UnixListener :: incoming(&self.inner)
}
pub fn local_addr ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: os :: unix :: net :: SocketAddr > ) {

    std :: os :: unix :: net :: UnixListener :: local_addr(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "local_addr"))
}
pub fn set_nonblocking ( & self , nonblocking : bool ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: os :: unix :: net :: UnixListener :: set_nonblocking(&self.inner, nonblocking)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "set_nonblocking", nonblocking))
}
pub fn take_error ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < core :: option :: Option < std :: io :: Error > > ) {

    std :: os :: unix :: net :: UnixListener :: take_error(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "take_error"))
}
pub fn try_clone ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > ) {

    std :: os :: unix :: net :: UnixListener :: try_clone(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "try_clone"))
}
}

#[cfg(unix)]
impl UnixStream {
#[cfg(feature = "peer_credentials_unix_socket")]
pub fn peer_cred ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: os :: unix :: net :: UCred > ) {

    std :: os :: unix :: net :: UnixStream :: peer_cred(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "peer_cred"))
}
#[cfg(feature = "unix_set_mark")]
pub fn set_mark ( & self , mark : u32 ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: os :: unix :: net :: UnixStream :: set_mark(&self.inner, mark)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "set_mark", mark))
}
#[cfg(feature = "unix_socket_ancillary_data")]
pub fn recv_vectored_with_ancillary ( & self , bufs : & mut [ std :: io :: IoSliceMut < '_ > ] , ancillary : & mut std :: os :: unix :: net :: SocketAncillary < '_ > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {

    std :: os :: unix :: net :: UnixStream :: recv_vectored_with_ancillary(&self.inner, bufs, ancillary)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "recv_vectored_with_ancillary", bufs, ancillary))
}
#[cfg(feature = "unix_socket_ancillary_data")]
pub fn send_vectored_with_ancillary ( & self , bufs : & [ std :: io :: IoSlice < '_ > ] , ancillary : & mut std :: os :: unix :: net :: SocketAncillary < '_ > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {

    std :: os :: unix :: net :: UnixStream :: send_vectored_with_ancillary(&self.inner, bufs, ancillary)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "send_vectored_with_ancillary", bufs, ancillary))
}
#[cfg(feature = "unix_socket_peek")]
pub fn peek ( & self , buf : & mut [ u8 ] ) -> crate :: rewrite_output_type ! ( std :: io :: Result < usize > ) {

    std :: os :: unix :: net :: UnixStream :: peek(&self.inner, buf)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "peek", buf))
}
pub fn connect < P : core :: convert :: AsRef < std :: path :: Path > > ( path : P ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > ) {
    let path = path.as_ref();

    std :: os :: unix :: net :: UnixStream :: connect(path)
        .map(Into::into)
        .with_context(|| crate::call_failed!(None::<()>, "std :: os :: unix :: net :: UnixStream :: connect", path))
}
pub fn connect_addr ( socket_addr : & std :: os :: unix :: net :: SocketAddr ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > ) {

    std :: os :: unix :: net :: UnixStream :: connect_addr(socket_addr)
        .map(Into::into)
        .with_context(|| crate::call_failed!(None::<()>, "std :: os :: unix :: net :: UnixStream :: connect_addr", socket_addr))
}
pub fn local_addr ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: os :: unix :: net :: SocketAddr > ) {

    std :: os :: unix :: net :: UnixStream :: local_addr(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "local_addr"))
}
pub fn pair ( ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( Self , Self ) > ) {

    std :: os :: unix :: net :: UnixStream :: pair()
        .map(|(x, y)| (x.into(), y.into()))
        .with_context(|| crate::call_failed!(None::<()>, "std :: os :: unix :: net :: UnixStream :: pair"))
}
pub fn peer_addr ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < std :: os :: unix :: net :: SocketAddr > ) {

    std :: os :: unix :: net :: UnixStream :: peer_addr(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "peer_addr"))
}
pub fn read_timeout ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < core :: option :: Option < core :: time :: Duration > > ) {

    std :: os :: unix :: net :: UnixStream :: read_timeout(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "read_timeout"))
}
pub fn set_nonblocking ( & self , nonblocking : bool ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: os :: unix :: net :: UnixStream :: set_nonblocking(&self.inner, nonblocking)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "set_nonblocking", nonblocking))
}
pub fn set_read_timeout ( & self , timeout : core :: option :: Option < core :: time :: Duration > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: os :: unix :: net :: UnixStream :: set_read_timeout(&self.inner, timeout)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "set_read_timeout", timeout))
}
pub fn set_write_timeout ( & self , timeout : core :: option :: Option < core :: time :: Duration > ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: os :: unix :: net :: UnixStream :: set_write_timeout(&self.inner, timeout)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "set_write_timeout", timeout))
}
pub fn shutdown ( & self , how : std :: net :: Shutdown ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( ) > ) {

    std :: os :: unix :: net :: UnixStream :: shutdown(&self.inner, how)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "shutdown", how))
}
pub fn take_error ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < core :: option :: Option < std :: io :: Error > > ) {

    std :: os :: unix :: net :: UnixStream :: take_error(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "take_error"))
}
pub fn try_clone ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > ) {

    std :: os :: unix :: net :: UnixStream :: try_clone(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "try_clone"))
}
pub fn write_timeout ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < core :: option :: Option < core :: time :: Duration > > ) {

    std :: os :: unix :: net :: UnixStream :: write_timeout(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "write_timeout"))
}
}
