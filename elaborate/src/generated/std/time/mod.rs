// This file was automatically generated by `elaborate`.
// https://github.com/smoelius/elaborate

#[allow(unused_imports)]
use anyhow::Context;



#[repr(transparent)]
pub struct Instant {
    pub(crate) inner: std :: time :: Instant,
}
impl Instant {
    pub fn to_inner(&self) -> &std :: time :: Instant {
        &self.inner
    }

    
    pub fn into_inner(self) -> std :: time :: Instant {
        self.inner
    }
}
impl<T> AsRef<T> for Instant where std :: time :: Instant: AsRef<T> {
    fn as_ref(&self) -> &T {
        <std :: time :: Instant as AsRef<T>>::as_ref(&self.inner)
    }
}

impl From<std :: time :: Instant> for Instant {
    fn from(value: std :: time :: Instant) -> Self {
        Self { inner: value }
    }
}

impl crate::Elaborate for std :: time :: Instant {
    type Output = Instant;
    fn elaborate(self) -> Self::Output {
        self.into()
    }
}
#[repr(transparent)]
pub struct SystemTime {
    pub(crate) inner: std :: time :: SystemTime,
}
impl SystemTime {
    pub fn to_inner(&self) -> &std :: time :: SystemTime {
        &self.inner
    }

    
    pub fn into_inner(self) -> std :: time :: SystemTime {
        self.inner
    }
}
impl<T> AsRef<T> for SystemTime where std :: time :: SystemTime: AsRef<T> {
    fn as_ref(&self) -> &T {
        <std :: time :: SystemTime as AsRef<T>>::as_ref(&self.inner)
    }
}

impl From<std :: time :: SystemTime> for SystemTime {
    fn from(value: std :: time :: SystemTime) -> Self {
        Self { inner: value }
    }
}

impl crate::Elaborate for std :: time :: SystemTime {
    type Output = SystemTime;
    fn elaborate(self) -> Self::Output {
        self.into()
    }
}


impl Instant {
pub fn checked_add ( & self , duration : core :: time :: Duration ) -> crate :: rewrite_output_type ! ( core :: option :: Option < Self > ) {

    std :: time :: Instant :: checked_add(&self.inner, duration)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "checked_add", duration))
}
pub fn checked_duration_since ( & self , earlier : std :: time :: Instant ) -> crate :: rewrite_output_type ! ( core :: option :: Option < core :: time :: Duration > ) {

    std :: time :: Instant :: checked_duration_since(&self.inner, earlier)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "checked_duration_since", earlier))
}
pub fn checked_sub ( & self , duration : core :: time :: Duration ) -> crate :: rewrite_output_type ! ( core :: option :: Option < Self > ) {

    std :: time :: Instant :: checked_sub(&self.inner, duration)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "checked_sub", duration))
}
pub fn duration_since ( & self , earlier : std :: time :: Instant ) -> core :: time :: Duration {

    std :: time :: Instant :: duration_since(&self.inner, earlier)
}
pub fn elapsed ( & self ) -> core :: time :: Duration {

    std :: time :: Instant :: elapsed(&self.inner)
}
pub fn now ( ) -> Self {

    std :: time :: Instant :: now().into()
}
pub fn saturating_duration_since ( & self , earlier : std :: time :: Instant ) -> core :: time :: Duration {

    std :: time :: Instant :: saturating_duration_since(&self.inner, earlier)
}
}

impl SystemTime {
pub fn checked_add ( & self , duration : core :: time :: Duration ) -> crate :: rewrite_output_type ! ( core :: option :: Option < Self > ) {

    std :: time :: SystemTime :: checked_add(&self.inner, duration)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "checked_add", duration))
}
pub fn checked_sub ( & self , duration : core :: time :: Duration ) -> crate :: rewrite_output_type ! ( core :: option :: Option < Self > ) {

    std :: time :: SystemTime :: checked_sub(&self.inner, duration)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "checked_sub", duration))
}
pub fn duration_since ( & self , earlier : std :: time :: SystemTime ) -> crate :: rewrite_output_type ! ( core :: result :: Result < core :: time :: Duration , std :: time :: SystemTimeError > ) {

    std :: time :: SystemTime :: duration_since(&self.inner, earlier)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "duration_since", earlier))
}
pub fn elapsed ( & self ) -> crate :: rewrite_output_type ! ( core :: result :: Result < core :: time :: Duration , std :: time :: SystemTimeError > ) {

    std :: time :: SystemTime :: elapsed(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "elapsed"))
}
pub fn now ( ) -> Self {

    std :: time :: SystemTime :: now().into()
}
}
