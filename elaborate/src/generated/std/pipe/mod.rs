// This file was automatically generated by `elaborate`.
// https://github.com/smoelius/elaborate

#[allow(unused_imports)]
use anyhow::Context;



#[cfg(feature = "anonymous_pipe")]
#[repr(transparent)]
pub struct PipeReader {
    pub(crate) inner: std :: pipe :: PipeReader,
}
#[cfg(feature = "anonymous_pipe")]
impl PipeReader {
    pub fn to_inner(&self) -> &std :: pipe :: PipeReader {
        &self.inner
    }

    
    pub fn into_inner(self) -> std :: pipe :: PipeReader {
        self.inner
    }
}
#[cfg(feature = "anonymous_pipe")]
impl<T> AsRef<T> for PipeReader where std :: pipe :: PipeReader: AsRef<T> {
    fn as_ref(&self) -> &T {
        <std :: pipe :: PipeReader as AsRef<T>>::as_ref(&self.inner)
    }
}
#[cfg(feature = "anonymous_pipe")]

impl From<std :: pipe :: PipeReader> for PipeReader {
    fn from(value: std :: pipe :: PipeReader) -> Self {
        Self { inner: value }
    }
}
#[cfg(feature = "anonymous_pipe")]

impl crate::Elaborate for std :: pipe :: PipeReader {
    type Output = PipeReader;
    fn elaborate(self) -> Self::Output {
        self.into()
    }
}
#[cfg(feature = "anonymous_pipe")]
#[repr(transparent)]
pub struct PipeWriter {
    pub(crate) inner: std :: pipe :: PipeWriter,
}
#[cfg(feature = "anonymous_pipe")]
impl PipeWriter {
    pub fn to_inner(&self) -> &std :: pipe :: PipeWriter {
        &self.inner
    }

    
    pub fn into_inner(self) -> std :: pipe :: PipeWriter {
        self.inner
    }
}
#[cfg(feature = "anonymous_pipe")]
impl<T> AsRef<T> for PipeWriter where std :: pipe :: PipeWriter: AsRef<T> {
    fn as_ref(&self) -> &T {
        <std :: pipe :: PipeWriter as AsRef<T>>::as_ref(&self.inner)
    }
}
#[cfg(feature = "anonymous_pipe")]

impl From<std :: pipe :: PipeWriter> for PipeWriter {
    fn from(value: std :: pipe :: PipeWriter) -> Self {
        Self { inner: value }
    }
}
#[cfg(feature = "anonymous_pipe")]

impl crate::Elaborate for std :: pipe :: PipeWriter {
    type Output = PipeWriter;
    fn elaborate(self) -> Self::Output {
        self.into()
    }
}


#[cfg(feature = "anonymous_pipe")]
pub fn pipe ( ) -> crate :: rewrite_output_type ! ( std :: io :: Result < ( std :: pipe :: PipeReader , std :: pipe :: PipeWriter ) > ) {

    std :: pipe :: pipe()
        .map(Into::into)
        .with_context(|| crate::call_failed!(None::<()>, "std :: pipe :: pipe"))
}

#[cfg(feature = "anonymous_pipe")]
impl PipeReader {
pub fn try_clone ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > ) {

    std :: pipe :: PipeReader :: try_clone(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "try_clone"))
}
}

#[cfg(feature = "anonymous_pipe")]
impl PipeWriter {
pub fn try_clone ( & self ) -> crate :: rewrite_output_type ! ( std :: io :: Result < Self > ) {

    std :: pipe :: PipeWriter :: try_clone(&self.inner)
        .map(Into::into)
        .with_context(|| crate::call_failed!(Some(&self.inner), "try_clone"))
}
}
